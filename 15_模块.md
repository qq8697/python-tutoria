# 模块和包
## 模块
模块：一个 `.py` 文件就是一个模块，模块名也是标识符需要符合标识符的命名规则，**模块内的全局变量、函数和类均可提供给外界直接使用**。
可以使用以下方式引入模块：
```
import 模块 [as 模块别名（大驼峰）]
from 模块 import 方法/变量/类 [as 别名]
from 模块 import * # 导入除`_`开头的所有 方法/变量/类，不推荐使用
```

说明：
1. 模块除了定义**变量、方法和类**，还包括可执行的代码，这些代码**只有在第一次被导入时才会执行**。（TODO 指的是项目还是某一模块？如何保证项目内同一模块只被执行一遍？有这个需求吗 -> 项目内模块被执行一次）

## `if __name__ == "__main__":` 与 模块测试
一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。
`__name__` 属性是python的内置的全局变量，表示模块的名称
1. 如果是被其它文件导入的，其值是模块名
2. 如果是当前执行的程序，其值是 `__main__`

所以 一般模块的测试代码如下：
```
if __name__ == "__main__":
	# 测试代码
```

内置函数 `dir()` 找出模块定义的名称（查看对象所有属性和方法）
```
dir(fibo)
# ['__name__', 'fib', 'fib2']
```

## 模块的搜索顺序
当import一个模块的时候，**解释器首先搜索具有该名称的内置模块，如果找不到，解释器依次搜索由一系列目录组成的列表，这个列表存储在 `sys.path` 中**，由输入脚本所在目录（未指定则为当前目录）、python PATH环境变量等初始化。（注意，给 `.py` 文件起名不要和系统的模块文件重名）（TODO 假设重名，导入的是哪个？）

```
import sys
sys.path
['', '/usr/lib/python3.5', '/usr/lib/python3.5/plat-x86_64-linux-gnu', '/usr/lib/python3.5/lib-dynload', '/usr/local/lib/python3.5/dist-packages', '/usr/lib/python3/dist-packages']
```
1. `''` 表示当前路径


初始化后，程序执行时可以修改 sys.path，添加新的路径，运行结束失效
```
import sys
sys.path.append('/home/xxx')
sys.path.insert(0, '/home/xxx')  # 可以确保先搜索这个路径
```

// 模块内置的 `__file__` 属性可以查看模块的完整路径
```
import re
print(re.__file__)
```

## “已编译”的python文件
为了加快模块的加载速度，python将每个模块的编译版本缓存在`__pycache__` 目录中，名称的格式为 `module.version.pyc` 如`spam.CPython-35.pyc`，此命名约定允许来自不同版本和不同python的编译文件可以共存。

Python根据编译后的版本检查源代码的修改日期，看它是否过期，是否需要重新编译。这是一个完全自动化的过程。此外，编译后的模块与平台无关，因此同一个库可以在具有不同体系结构的系统之间共享。

Python在两种情况下不会检查缓存
1. 总是重新编译并且不存储直接从命令行加载的模块的结果。
2. 如果没有源模块，它不会检查缓存。要支持非源（仅编译）分发，编译的模块必须在源目录中，并且不能有源模块。

注意，当程序从.pyc文件中读取时，其运行速度不会比从.py文件中读取时快多少；.pyc文件唯一快的地方是加载速度。

## 包
包：是一个目录，包名也是标识符需要符合标识符的命名规则，包含多个模块，可以一次性导入多个模块，包有一个必须存在的特殊文件** `__init__.py`，      **：
```
# __init__.py
from . import 模块名1
from . import 模块名2
```
```
# other.py
import 包名
from 包名 import 方法/变量/类/子包/模块
from 包名 import * # 不推荐
```

说明：
1. `from package import item` item 可以是子包，也可以是模块，也可以是包内定义的方法、变量和类。import语句首先测试 item 是否在包中定义，如果不存在则假定它是一个模块去加载（load）它，如果找不到，则抛出 `ImportError` 异常。
1. `import item.subitem.subsubitem`， 除最后一项外都必须是包，最后一项可以是模块或包，但，不能是在前一项中定义的方法、变量或类。
2. `from package import *`，导入 `__init__.py` 中 `__all__` 列表中包含的模块，如果未定义 `__all__` ，并不会导入所有子模块，而是导入包内定义的方法、变量和类以及被 import 进来的模块

模块，让你不用担心不同模块之间的全局变量相互影响的问题；（注意：模块内的变量不要和内置函数重名，模块名不要和内置模块重名）
包，让你不用担心不同包之间的模块重名问题。（注意：模块名不要和内置模块重名）

## 引入包的概念后，再议模块搜索顺序
在导入一个包的时候，Python 会根据 `sys.path` 中的目录来寻找这个包中包含的子目录。（？TODO还是会先搜索有该名称的内置模块吗）（注意：模块名不要和内置模块重名）（TODO 假设重名，导入的是哪个？）

## 番内：发布模块（自己开发的模块，分享给其他人/自己重复使用）
1. 制作发布压缩包
	1. 创建 `setup.py` （和包同级目录）
		```
		from distutils.core import setup
		setup(
			name="包名",
			description="描述信息",
			long_description="完整描述信息",
			author="作者",
			author_email="邮箱",
			url="主页",
			py_modules=["包名.模块名1", "包名.模块名2"]
		)
		```
	2. 构建模块 `python3 setup.py build`
	3. 生成发布压缩包 `python3 setup.py sdist` -> 生成 `包名-1.0.tar.gz`
4. 安装模块压缩包
	1. `tar -zxvf 包名-1.0.tar.gz`
	2. `cd 包名-1.0`
	2. `sudo python setup.py install`
5. 卸载（直接从安装目录下删除已安装模块的目录即可）
	1. `cd /usr/local/lib/python3.5/dist-packages/`
	2. `sudo rm -r 包名`
	


# 参考文档
1. 官网 [模块](https://docs.python.org/3.5/tutorial/modules.html)