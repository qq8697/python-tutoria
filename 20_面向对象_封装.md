# 面向对象
面向对象的一些术语：类、实例、方法（实例方法、类方法、静态方法）、属性（实例属性、类属性）、方法重写等

## 封装
定义类和创建对象
```
class Cat:
	def __init__(self, name):
		self.name = name
	def eat(self):
		print('%s is eating' % self.name)

tom = Cat("Tom")
tom.eat()
print(tom)
```

使用 `类名()` 创建对象时，会自动执行以下操作：
1. 创建对象，为对象在内存中分配空间 ->  `__new__` 
2. 初始化，为对象的属性设置初始值 -> `__init__`

`tom` 变量引用了新建的猫对象，记录其在内存中的地址 `print(tom)` 的结果是其16进制表示的内存地址。

实例属性和实例方法（也叫类的方法）：
实例初始化时会自动调用 `__init__` 方法，在其内部为实例属性赋值。
实例方法同普通的函数一样，使用 `def` 定义，不同之处在于必须有一个额外的参数，按照惯例是 `self`，在函数中代表实例对象。

## 再议封装：类属性、类方法|类的私有属性、方法|静态方法|实例属性、方法
python 中一切皆对象，类同样也是拥有自己的属性和方法，同样会被加载到内存中且只有一份，通过 `类名.属性名` 和 `类名.方法名()` 直接访问

类属性
1. **类属性用来记录与这个类相关** 的特征，如该类实例的个数。
3. 属性向上查找机制：首先在对象内部查找对象的实例属性，没有找到会向上寻找类属性，所以 `实例.类属性` 也可以访问类属性，但不推荐；
4. `实例.类属性 = 值` 赋值时只会给实例对象动态添加一个属性，不会影响到类属性的值
5. //类属性是共享的，不应使用可变数据类型做类属性（TODO 用可变数据类型有意义吗）

类方法
使用 `@classmethod` 装饰器标识这是一个类方法，`cls` 参数和实例方法的 `self` 参数类似，是惯用名称，指代类对象。

```
class Cat:
	cat_count = 0
	
	def __init__(self, name):
		self.name = name
		Cat.cat_count += 1
	
	def eat(self):
		print('%s is eating' % self.name)

	@classmethod
	def show_cat_count(cls):
		print('there are %s cats' % cls.cat_count)

tom = Cat("Tom")
tommy = Cat("Tommy")
Cat.show_cat_count()

print(Cat.cat_count, Cat.eat)
Cat.eat(tommy)
```
// `Cat.eat` 和 `Cat.cat_count` 一样，也是有效的引用，返回的是函数对象，`类名.实例方法` 可以被调用，传入一个实例对象即可。（类似于js的call）


静态方法
一般在**即不访问实例属性，也不访问类属性** 时使用，所以无参数，用 `@staticmethod` 装饰器标识，通过 `类名.方法名()` 调用
```
class Cat:

	def __init__(self, name):
		self.name = name

	def eat(self):
		print('%s is eating' % self.name)

	@staticmethod
	def desc():
		print('cats are our friends')

Cat.desc()
```


类的私有属性和私有方法
**在外部以及子类无法直接访问**
1.  是特殊的类属性和方法，以 `__` 开头 
1.  是无法直接访问，不是不能访问，python 实际对名称做了一些特殊处理，处理方式为： `__xx` -> `_类名__xx`，python没有真正的私有。

```
class Cat:
	__is_tailless = False

	def __init__(self, name):
		self.name = name

	def eat(self):
		print('%s is eating' % self.name)

	def has_tail(self):
		print('this cat has tail? %s' % self.__is_tailless) # 类内部可以访问私有属性

# 类外部不可以直接访问类的私有属性
# print(Cat.__is_tailless) # AttributeError
print(Cat._Cat__is_tailless)

class Tailless(Cat):
	def __init__(self, name, is_tailless):
		self.name = name
		# 子类内部不可以直接访问父类的私有属性
		# Tailless.__is_tailless = is_tailless
		Tailless._Cat__is_tailless = is_tailless

	def has_tail(self):
		print('this cat has tail? %s' % self._Cat__is_tailless) # 这里同样需要改写

tom = Cat('tom')
tom.has_tail() # 通过公有方法间接访问私有属性和方法
tommy = Tailless('tommy', True)
tommy.has_tail()
```

小结
1. 实例方法：方法内部需要访问实例属性，方法内部使用 `类名.类属性` 访问类属性
2. 类方法：方法内部**只需要访问类属性**
3. 静态方法：方法内部**不需要访问实例属性和类属性**

作业：实例属性和方法、类属性和方法、静态方法综合应用
```
Game类
属性：
类属性 top_score 历史最高分
实例属性 player_name 当前玩家游戏姓名
方法：
静态方法 show_help 帮助信息
类方法 show_top_score 显示历史最高分
实例方法 start_game 玩家开始游戏
```

## 番内：类特殊成员
使用 `dir()` 函数可以以列表的形式返回一个对象的所有属性和方法
```
class Cat:
	__private = 'private'
	def __init__(self, name):
		self.name = name

tom = Cat("Tom")
print(dir(tom))
print(tom.__dict__)

# ['_Cat__private', '__class__', '__dict__', '__init__',  '__module__', '__new__', '__repr__', '__str__',... , 'name']
```
**`__xx__` 不是类的私有属性和私有方法，在类的外部可以访问**，如 `tom.__dict__`


# 参考文档
1. 官网 [类](https://docs.python.org/3.5/tutorial/classes.html) | [super]()
2. 菜鸟教程 [super详解](https://www.runoob.com/w3cnote/python-super-detail-intro.html) 