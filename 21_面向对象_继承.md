## 继承：子类拥有所有父类的所有的方法和属性（？TODO 所有吗？）
单继承
```
class Cat:

	def __init__(self, name):
		self.name = name

	def eat(self):
		print('%s is eating' % self.name)

class Tailless(Cat):

	def __init__(self, name, is_tailless):
		Cat.__init__(self, name)
		# super().__init__(name)
		self.is_tailless = is_tailless

	def eat(self):
		print('%s is eating, %s has %s tail' % (self.name, self.name, 'no' if self.is_tailless else ''))

tommy = Tailless('tommy', True)
tommy.eat()
```
// 子类对象不能在自己的方法内部直接访问父类的私有属性和方法，可以通过父类的共有方法间接访问父类的私有属性和方法


多重继承
```
class Cat:

	def __init__(self, name):
		self.name = name

	def eat(self):
		print('%s is eating' % self.name)

class Pet:
	def __init__(self, owner):
		self.owner = owner

	def show_owner(self):
		print('owner is %s' % self.owner)

class Tailless(Cat, Pet):

	def __init__(self, name, is_tailless, owner):
		Cat.__init__(self, name)
		Pet.__init__(self, owner)
		self.is_tailless = is_tailless

	def eat(self):
		print('%s is eating, %s has %s tail' % (self.name, self.name, 'no' if self.is_tailless else ''))

tommy = Tailless('tommy', True, 'templar')
tommy.eat()
tommy.show_owner()
```
// 如果不同的父类存在同名的属性和方法，避免使用多继承

`super` 典型用例：
1. **单一继承中引用父类而无需显式命名**，即 `super().__init__` 和 `类名.__init__` 在单继承上无差；
2. 用于动态环境中**支持多重继承**

	> The second use case is to support cooperative multiple inheritance in a dynamic execution environment. 
	>  This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that this method have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime).


方法重写（override）子类扩展或修改父类的方法
```
class Cat:

	def __init__(self, name):
		self.name = name

	def eat(self):
		print('%s is eating' % self.name)

class Tailless(Cat):

	def __init__(self, name, is_tailless):
		Cat.__init__(self, name)
		self.is_tailless = is_tailless

	def eat(self):
		super().eat()
		if self.is_tailless:
			print('and %s has no tail' % self.name)

tommy = Tailless('tommy', True)
tommy.eat()
```
重写父类方法时，可以调用父类的方法做功能扩展。 -`super().父类方法()` （？TODO 多继承怎么办）


番内：新式类和旧式类
1. 新式类：以 `object` 为基类的类（推荐使用）
1. 旧式类：不以 `object` 为基类的类（不推荐）
在 python3 中如果没有指定父类，默认 `object` 作为该类的基类，在python2 中如果没有指定父类，则不会以 `object` 作为基类
新式类和旧式类在多继承时会影响到方法的搜索顺序，为了保证代码同时在python2 和 python3 运行，在定义类时，如果没有父类，建议统一继承自 `object`:
```
class 类名(object):
	pass
```
一个类的父类不是 `object`，重写 `__init__` 方法时一定要先 `super()` 一下父类的 `__init__` 方法，保证父类中实现的 `__init__` 代码能够被正常执行（TODO？不懂）

python中的MRO
`类名.__mro__` 可以查看方法搜索顺序（应用场景 C继承自A和B并且AB有同名方法，C会调用哪个父类的方法呢？使用MRO查看方法的搜索顺序）（类似于JavaScript的属性查找 TODO后续介绍）
该属性是动态的，在继承层级结构更新时改变
## MRO method resolution order 

# 参考文档
1. 官网 [类](https://docs.python.org/3.5/tutorial/classes.html) | [super](https://docs.python.org/3.5/library/functions.html#super) | [MRO](https://www.python.org/download/releases/2.3/mro/)
2. [spuer 指南](https://rhettinger.wordpress.com/2011/05/26/super-considered-super/)（科学上网）
2. 菜鸟教程 [super详解](https://www.runoob.com/w3cnote/python-super-detail-intro.html) 