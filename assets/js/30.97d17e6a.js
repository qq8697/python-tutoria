(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{390:function(e,_,v){"use strict";v.r(_);var o=v(25),t=Object(o.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"socket-简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#socket-简介"}},[e._v("#")]),e._v(" socket 简介")]),e._v(" "),v("p",[e._v("socket（套接字），是"),v("strong",[e._v("操作系统提供的用于（不同主机）进程间通信")]),e._v("的一种方式，微信、QQ 等服务多是基于 socket 实现的。 socket API 最初是为 Unix 操作系统开发的，但现在几乎所有的操作系统和语言都有其变体存在。")]),e._v(" "),v("p",[e._v("常用的操作系统套接字 API：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("s = socket(<parameters>)")])]),e._v(" "),v("li",[v("code",[e._v("bind(s, <local IP:port>)")])]),e._v(" "),v("li",[v("code",[e._v("connect(s, <remote IP:port>)")])]),e._v(" "),v("li",[v("code",[e._v("listen(s,...)")])]),e._v(" "),v("li",[v("code",[e._v("s2 = accept(s)")])]),e._v(" "),v("li",[v("code",[e._v("n = read(s, buffer, n)")])]),e._v(" "),v("li",[v("code",[e._v("n = write(s, buffer, n)")])]),e._v(" "),v("li",[v("code",[e._v("close(s)")])]),e._v(" "),v("li",[v("code",[e._v("shutdown(s, <side>)")])]),e._v(" "),v("li",[v("code",[e._v("getsocketopt(s,...)")])]),e._v(" "),v("li",[v("code",[e._v("setsocketopt(s,...)")])])]),e._v(" "),v("h2",{attrs:{id:"socket-模块"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#socket-模块"}},[e._v("#")]),e._v(" socket 模块")]),e._v(" "),v("p",[e._v("是用 Python 的面向对象风格对 Unix 系统调用和套接字库接口的直译。函数 "),v("code",[e._v("socket()")]),e._v(" 返回一个套接字对象，其方法是对各种套接字系统调用的实现。")]),e._v(" "),v("h3",{attrs:{id:"socket-函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#socket-函数"}},[e._v("#")]),e._v(" socket() 函数")]),e._v(" "),v("p",[v("code",[e._v("socket.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None)")])]),e._v(" "),v("ul",[v("li",[v("code",[e._v("family")]),e._v(" "),v("a",{attrs:{href:"https://docs.python.org/3.5/library/socket.html#socket-families",target:"_blank",rel:"noopener noreferrer"}},[e._v("地址簇"),v("OutboundLink")],1),e._v("。 （"),v("code",[e._v("AF_INET")]),e._v("（默认，用于 Internet 进程间通信）、 "),v("code",[e._v("AF_INET6")]),e._v("、 "),v("code",[e._v("AF_UNIX")]),e._v("（用于同一台机器进程间通信）、 "),v("code",[e._v("AF_CAN")]),e._v("、 "),v("code",[e._v("AF_PACKET")]),e._v(" 或 "),v("code",[e._v("AF_RDS")]),e._v(" 其中之一）")]),e._v(" "),v("li",[v("code",[e._v("type")]),e._v(" 套接字类型。（"),v("code",[e._v("SOCK_STREAM")]),e._v("（默认，流式套接字，主要用于 TCP 协议）、 "),v("code",[e._v("SOCK_DGRAM")]),e._v("（数据报套接字，主要用于 UDP 协议）、 "),v("code",[e._v("SOCK_RAW")]),e._v(" 或其他 "),v("code",[e._v("SOCK_")]),e._v(" 常量之一）")]),e._v(" "),v("li",[v("code",[e._v("proto")]),e._v(" 协议号。")]),e._v(" "),v("li",[v("code",[e._v("fileno")]),e._v(" 从该文件描述符中自动检测 "),v("code",[e._v("family")]),e._v("、 "),v("code",[e._v("type")]),e._v(" 和 "),v("code",[e._v("proto")]),e._v(" 的值。")])]),e._v(" "),v("p",[e._v("此外，"),v("code",[e._v("socketpair()")]),e._v("、 "),v("code",[e._v("create_connection()")]),e._v("、 "),v("code",[e._v("fromfd()")]),e._v("、 "),v("code",[e._v("fromshare()")]),e._v(" 也可以创建套接字对象。")]),e._v(" "),v("h3",{attrs:{id:"套接字对象的常用方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#套接字对象的常用方法"}},[e._v("#")]),e._v(" 套接字对象的常用方法")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("bind(address)")]),e._v(" 将套接字绑定到 "),v("code",[e._v("address")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("listen([backlog])")]),e._v(" 启动一个服务器用于接受连接。")]),e._v(" "),v("li",[v("code",[e._v("accept()")]),e._v(" 接受一个连接，此 scoket 必须绑定到一个地址上并且监听连接。返回值是 "),v("code",[e._v("(conn, address)")]),e._v(" 元组，"),v("code",[e._v("conn")]),e._v(" 是一个新的套接字对象，用于在此连接上收发数据。")]),e._v(" "),v("li",[v("code",[e._v("connect(address)")]),e._v(" 连接远程套接字。")]),e._v(" "),v("li",[v("code",[e._v("close()")]),e._v(" 将套接字标记为关闭。")])]),e._v(" "),v("hr"),e._v(" "),v("ul",[v("li",[v("code",[e._v("recv(bufsize[, flags])")]),e._v(" 从套接字接收数据，返回值是一个字节对象，表示接收到的数据。")]),e._v(" "),v("li",[v("code",[e._v("recvfrom(bufsize[, flags])")]),e._v(" 从套接字接收数据，返回值是一对 "),v("code",[e._v("(bytes, address)")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("send(bytes[, flags])")]),e._v(" 发送数据给套接字。")]),e._v(" "),v("li",[v("code",[e._v("sendto(bytes, address)")]),e._v(" 发送数据给套接字，本套接字不应连接到远程套接字，而应由 "),v("code",[e._v("address")]),e._v(" 指定目标套接字。")]),e._v(" "),v("li",[v("code",[e._v("sendall(bytes[, flags])")]),e._v(" 发送数据给套接字，本方法持续从 "),v("code",[e._v("bytes")]),e._v(" 发送数据，直到所有数据都已发送或发生错误为止。成功后会返回 "),v("code",[e._v("None")]),e._v("。")])]),e._v(" "),v("hr"),e._v(" "),v("ul",[v("li",[v("code",[e._v("setblocking(flag)")]),e._v(" 设置套接字为阻塞或非阻塞模式。")]),e._v(" "),v("li",[v("code",[e._v("settimeout(value)")]),e._v(" 为阻塞套接字的操作设置超时。")]),e._v(" "),v("li",[v("code",[e._v("setsockopt(level, optname, None, optlen: int)")]),e._v("设置给定套接字选项的值。")]),e._v(" "),v("li",[v("code",[e._v("getpeername()")]),e._v(" 返回套接字连接到的远程地址。")]),e._v(" "),v("li",[v("code",[e._v("getsockname()")]),e._v(" 返回套接字本身的地址。")]),e._v(" "),v("li",[v("code",[e._v("getsockopt(level, optname[, buflen])")]),e._v(" 返回指定套接字选项的值。")]),e._v(" "),v("li",[v("code",[e._v("gettimeout()")]),e._v(" 返回套接字操作相关的超时秒数（浮点数），未设置超时则返回 None。")])]),e._v(" "),v("hr"),e._v(" "),v("ul",[v("li",[v("code",[e._v("dup()")]),e._v(" 创建套接字的副本。")]),e._v(" "),v("li",[v("code",[e._v("shutdown(how)")]),e._v(" 关闭一半或全部的连接。")]),e._v(" "),v("li",[v("code",[e._v("detach()")]),e._v(" 将套接字对象置于关闭状态，而底层的文件描述符实际并不关闭。返回该文件描述符，使其可以重新用于其他目的。")]),e._v(" "),v("li",[v("code",[e._v("makefile(mode='r', buffering=None, *, encoding=None, errors=None, newline=None)")]),e._v(" 返回与套接字关联的 文件对象。")]),e._v(" "),v("li",[v("code",[e._v("sendfile(file, offset=0, count=None)")]),e._v(" 使用高性能的 "),v("code",[e._v("os.sendfile")]),e._v(" 发送文件，直到达到文件的 EOF 为止，返回已发送的字节总数。")]),e._v(" "),v("li",[v("code",[e._v("fileno()")]),e._v(" 返回套接字的文件描述符（一个小整数），失败返回 -1。（配合 "),v("code",[e._v("select.select()")]),e._v(" 使用）")])]),e._v(" "),v("h3",{attrs:{id:"socket-模块的其它函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#socket-模块的其它函数"}},[e._v("#")]),e._v(" socket 模块的"),v("a",{attrs:{href:"https://docs.python.org/3.5/library/socket.html#other-functions",target:"_blank",rel:"noopener noreferrer"}},[e._v("其它函数"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("提供与网络相关的服务，如 "),v("code",[e._v("socket.setdefaulttimeout(timeout)")]),e._v(" 设置用于新套接字对象的默认超时。")]),e._v(" "),v("h3",{attrs:{id:"套接字超时"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#套接字超时"}},[e._v("#")]),e._v(" 套接字超时")]),e._v(" "),v("p",[e._v("一个套接字对象可以处于以下三种模式之一："),v("strong",[e._v("阻塞、非阻塞或超时")]),e._v("。套接字默认以阻塞模式创建，但是可以调用 "),v("code",[e._v("setdefaulttimeout()")]),e._v(" 来更改。")]),e._v(" "),v("p",[v("code",[e._v("connect()")]),e._v(" 操作受超时设置的约束，通常在调用 "),v("code",[e._v("connect()")]),e._v(" 之前调用 "),v("code",[e._v("settimeout()")]),e._v("。（注意，无论 Python 套接字超时设置如何，系统网络栈都有可能返回自带的连接超时错误。）")]),e._v(" "),v("p",[v("code",[e._v("accept()")]),e._v(" 方法返回的套接字行为取决于监听套接字的设置：")]),e._v(" "),v("ul",[v("li",[e._v("如果监听套接字处于 阻塞模式 或 超时模式，则 "),v("code",[e._v("accept()")]),e._v(" 返回的套接字处于 阻塞模式；")]),e._v(" "),v("li",[e._v("如果监听套接字处于 非阻塞模式，那么 "),v("code",[e._v("accept()")]),e._v(" 返回的套接字是阻塞还是非阻塞取决于操作系统。（如果要确保跨平台时的正确行为，建议手动覆盖此设置。）")])]),e._v(" "),v("h2",{attrs:{id:"参考文档"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[e._v("#")]),e._v(" 参考文档")]),e._v(" "),v("ol",[v("li",[e._v("HTTP权威指南 p84")]),e._v(" "),v("li",[e._v("官网 "),v("a",{attrs:{href:"https://docs.python.org/3.5/library/socket.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("socket"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=t.exports}}]);