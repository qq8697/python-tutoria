# 变量的作用域

## 函数与变量的作用域
函数的执行会引入一个符号表（symbol table），存储函数的局部变量，准确的说，函数中所有赋值的变量都将存储在本地符号表中，变量引用首先会查找本地符号表，然后查找闭包的符号表，然后查找全局符号表，最后查找内置符号表，因此**全局变量在函数中可以被引用，但是不能直接赋值**（使用global声明除外）。
实参在被函数被调用时引入到被调用函数的本地符号表中，**传递的值（始终是）是对象引用，而不是对象的值**。

## 变量查找顺序
1. L：local，局部符号表，即函数中定义的变量和形参；
2. E：enclosing，闭包符号表，即嵌套的父级函数的局部符号表，即包含此函数的上级函数的局部符号表，但不是全局的；
3. G：globa，全局符号表，就是模块级别定义的变量；
4. B：built-in，内置符号表，比如int等。

## 局部变量和全局变量：
1. 局部变量的生命周期：从变量被创建到被系统回收的过程，局部变量在函数执行时才会被创建，函数执行结束后被系统回收。
2. python不允许直接在函数内部修改全局变量的值（可以引用但不可以修改）
	1. 如果使用赋值语句会在函数内部定义一个同名的局部变量
	1. 使用 `global` 声明后可以在函数内部修改全局变量的值
2. 全局变量和局部变量名同名建议：全局变量加`gl_`前缀
3. 全局变量位置应在所有函数之前（？TODO）

```
t = 100
def f1():
	t = 99
	print(t)
def f2():
	print(t)
f1()
f2()
def f3():
	global t
	t = 98
f3()
```

## global 和 nonlocal 关键字
```
def scope_test():
    def do_local():
        spam = "local spam"

    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"

    def do_global():
        global spam
        spam = "global spam"

    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)

scope_test()
print("In global scope:", spam)
```

## 引入模块的概念后，再谈全局变量
**每个模块都有自己的专有符号表（symbol table），模块中定义的所有函数都将其用作全局符号表**。因此，**模块的作者可以在模块中使用全局变量，而不必担心与用户的全局变量冲突**。

使用 `from module import item` 方式，可以将 方法/变量/类 引入到当前操作模块的符号表中，当前操作模块代码需要避免重名。

## 多模块开发中变量共享问题
`import` 其实是两步：一是导入模块，二是变量名指向这个模块；

一个常见的应用场景，main.py 主模块，handle_msg.py 数据处理模块，recv_msg.py 数据接收模块，common.py 公共数据模块
在 handle_msg 和 recv_msg 中导入 common 的变量有两种方式：

1. `import common`，使用 `data.变量1` 调用
2. `from common import 变量1`，直接使用 `变量1`

因为 **`import` 会避免重复导入模块，使用前一种方式，两次导入的 common 均指向同一个内存对象，handle_msg.py 和 recv_msg.py 其实“共用”一个 `common`**；

**而后者仅仅是定义了一个同名变量，初始指向 common 中的 `变量1`的值，但是对这个同名变量赋新值后，指向新的内存对象，并不是修改 common 模块中的 `变量1`，这样 handle_msg.py 和 recv_msg.py 使用的并不是同一个 `变量1`**，做不到数据共享。

common.py
```
RECV_DATA_LIST = []
HANDLE_FLAG = False

# print('common 模块被多个模块引入 可执行代码仅执行一次')
```

recv_msg.py
```
from common import RECV_DATA_LIST
from common import HANDLE_FLAG
# import common


def recv_msg():
    print("--->接收网络数据")
    for i in range(5):
        RECV_DATA_LIST.append(i)
    print('已接收数据 %s' % RECV_DATA_LIST)


def recv_msg_next():
    if HANDLE_FLAG:
    # if common.HANDLE_FLAG:
        print("--->之前的数据已经处理完成，接收新的数据")
        for i in range(5,10):
            RECV_DATA_LIST.append(i)
    else:
        print("--->之前的数据未处理完，等待中....")
    print('当前数据 %s' % RECV_DATA_LIST)
```

handle_msg.py
```
from common import RECV_DATA_LIST
from common import HANDLE_FLAG
# import common

def handle_data():
    print("--->处理数据")
    for i in range(len(RECV_DATA_LIST)):
        print("处理 %s" % RECV_DATA_LIST.pop(0))

    # HANDLE_FLAG设置为True，意味着处理完成
    global HANDLE_FLAG
    HANDLE_FLAG = True
    # common.HANDLE_FLAG = True

```

main.py
```
from recv_msg import *
from handle_msg import *


def main():
    # 接收数据
    recv_msg()
    # 处理数据
    handle_data()
    # 判断如果处理完成，则接收其它数据
    recv_msg_next()


if __name__ == "__main__":
    main()
```

# 参考文档
1. 官网 [global and nonlocal](https://docs.python.org/3.5/tutorial/classes.html#scopes-and-namespaces-example)
2. 菜鸟教程 [命名空间和作用域](https://www.runoob.com/python3/python3-namespace-scope.html)