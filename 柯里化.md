# 高阶函数的应用

## 函数柯里化 currying
一个 currying 的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来，**待到函数被真正求值的时候，之前传入的所有参数会被一次性用于求值**。

1. 编写计算每天开销的函数，月底求和
	```
	def cost(*args):
	    money = 0
	    for i in args:
	        money += i
	    return money
	
	# 1月1日 买鞋300，裤子200，衣服100
	c1 = cost(100, 200, 300)
	# 1月2日 逛超市60
	c2 = cost(60)
	...
	# 当月费用
	print(c1 + c2)
	```

2. 优化：不关心每天花多少，月底一次性计算。（设无参数传递时一次性计算）
	```
	def cost(*args):
	    f_args = []
	
	    def f(*args):
	        nonlocal f_args
	        if args:
	            f_args += args
	            return f
	        else:
	            money = 0
	            for i in f_args:
	                money += i
	            return money
	
	    return f(*args)
	
	# 1月1日 买鞋300，裤子200，衣服100
	cost = cost(100, 200, 300)
	# 1月2日 逛超市60
	cost = cost(60)
	# 当月费用
	print(cost())
	```

3. 以上函数不是 currying 函数的完整实现，主要用于理解其思想，currying 化的函数常用调用方法如下：
	```
	# 与上面方法等价
	print(cost(100, 200, 300)(60)())
	```

4. 优化：拆分出通用函数 `curry` 和业务函数 `cost`
	```
	def cost(*args):
	    money = 0
	    for i in args:
	        money += i
	    return money
	
	def curry(func):
	    f_args = []
	    def f(*args):
	        nonlocal f_args
	        if args:
	            f_args += args
	            return f
	        else:
	            return func(*f_args)
	    return f
	
	cost = curry(cost)
	print(cost(100, 200, 300)(60)())
	```

5. 定义一个 `add` 函数，用 `curry` 将其 currying（柯里化）
	```
	def add(x, y, z):
	    return x + y + z
	
	add = curry(add)
	print(add(3, 5)(8)())
	```

柯里化与偏函数的区别：
偏函数：固定了函数的一个或多个参数，返回一个新的函数。
柯里化：**把一个有多个参数的函数变成只有一个参数的函数，并且返回接受余下的参数而且返回结果的新函数** -> `f(x,y,z) -> f(x)(y)(z)`。（python 版用接收 `tuple` 参数，致使“看起来”不是只有一个参数。）

小结，柯里化的理解：
形式上：把一个有多个参数的函数变成只有一个参数的函数，并且返回接受余下的参数而且返回结果的新函数。
功能上：待到真正求值的时候，之前传入的所有参数一次求值。

# 参考文档
[Functional Programming](http://www.defmacro.org/2006/06/19/fp.html) 一个使用 Java 示例的函数式编程的总体介绍。
- Higher Order Functions 高阶函数
- Currying 柯里化
- Lazy Evaluation 懒加载
- Continuations
- Closures 闭包

[Python Advanced Course Topics](https://www.python-course.eu/currying_in_python.php)