`__del__` 和 `__str__`
```
class Cat:
	def __init__(self, name):
		self.name = name
	def eat(self):
		pass
	def __del__(self):
		print("del")
	def __str__(self):
		return "some str"

tom = Cat("Tom")
print(tom)
print("process over")
```

1. `__del__` 对象从内存中销毁前自动调用，用于在对象被销毁前，再做一些事情。  `process over` 先于 `del`，因为 `tom` 是全局变量，顺序代码执行完才销毁，才会执行 `__del__` 回调。
2. `__str__` 返回对象的描述信息，用于自定义 `print` 打印对象变量的内容， `print(tom)` 的结果从`<__main__.Cat at 0x066E8030>` -> `"some str"`

`__new__` 和 `__init__`
3. 使用 `类名()` 创建对象时，python解释器首先会调用 `__new__` 方法为对象分配空间， `__new__` 是由 `object` 基类提供的静态方法，主要作用有二：
	1. 在内存中为对象分配空间
	2. 返回对象的引用
4. python解释器获得对象的引用后，将引用作为第一个参数传递给`__init__` 方法对对象进行初始化
5. 重写	`__new__` 方法（固定形式）： 
	1. 必修 `return` 返回，否则python解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法
	2. `__new__` 是静态方法，需要手动传递 `cls` 参数
	```
	def __new__ (cls, *args, **kw)
		return super().__new__(cls)
		```
例子：单例设计模式
1. 应用场景：音乐播放器对象、回收站对象、打印机对象
2. 类创建的对象，在系统中只有唯一的一个实例，每次执行`类名()`返回的对象，都是同一个对象，内存地址是相同的
3. 实现方法：
	```
	class Singleton(object):
		
		instance = None
		inited = False
		
		def __new__(cls, *args, **kw):
			if cls.instance is None:
				cls.instance = super().__new__(cls)
			return cls.instance
			
		def __init__(self):
			if Singleton.inited:
				return
			print("init action")	
			Singleton.inited = True
	```
	1. 定义一个类属性，初始值是None，用于记录对单例对象的引用
	2. 重写`__new__` 方法
		1. 如果类属性 is None，调用父类方法分配空间，并在类属性中记录结果
		2. 返回类属性中记录的对象引用
4. 如上，初始化方法还会被再次调用！解决方案：
	1. 定义一个类属性，初始值为False，标记是否执行过初始化动作
	2. 在__init__方法中判断这个标记，如果为False就执行初始化动作，并修改值为True